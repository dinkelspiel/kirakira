//// Code generated by parrot. DO NOT EDIT.
////

import gleam/option.{type Option}
import gleam/dynamic/decode
import parrot/dev

pub fn create_auth_code(token token: String, creator_id creator_id: Int){
  let sql = "INSERT INTO
    auth_code (token, creator_id)
VALUES
    (?, ?)"
  #(sql, [dev.ParamString(token), dev.ParamInt(creator_id)], )
}

pub type GetAuthCodeByToken {
  GetAuthCodeByToken(
    id: Int,
    token: String,
    creator_id: Int,
    used: Int
  )
}

pub fn get_auth_code_by_token(token token: String){
  let sql = "SELECT
    auth_code.id,
    auth_code.token,
    auth_code.creator_id,
    auth_code.used
FROM
    auth_code
WHERE
    auth_code.token = ?"
  #(sql, [dev.ParamString(token)], get_auth_code_by_token_decoder())
}

pub fn get_auth_code_by_token_decoder() -> decode.Decoder(GetAuthCodeByToken) {
  use id <- decode.field(0, decode.int)
  use token <- decode.field(1, decode.string)
  use creator_id <- decode.field(2, decode.int)
  use used <- decode.field(3, decode.int)
  decode.success(GetAuthCodeByToken(id: , token: , creator_id: , used: ))
}

pub fn update_auth_code_as_used(id id: Int){
  let sql = "UPDATE auth_code
SET
    used = TRUE
WHERE
    id = ?"
  #(sql, [dev.ParamInt(id)], )
}

pub type GetUserIsAdmin {
  GetUserIsAdmin(
    id: Int,
    user_id: Int
  )
}

pub fn get_user_is_admin(user_id user_id: Int){
  let sql = "SELECT
    user_admin.id,
    user_admin.user_id
FROM
    user_admin
WHERE
    user_admin.user_id = ?"
  #(sql, [dev.ParamInt(user_id)], get_user_is_admin_decoder())
}

pub fn get_user_is_admin_decoder() -> decode.Decoder(GetUserIsAdmin) {
  use id <- decode.field(0, decode.int)
  use user_id <- decode.field(1, decode.int)
  decode.success(GetUserIsAdmin(id: , user_id: ))
}

pub fn create_user(username username: String, email email: String, password password: String, invited_by invited_by: Int){
  let sql = "INSERT INTO
    user (username, email, password, invited_by)
VALUES
    (?, ?, ?, ?)"
  #(sql, [dev.ParamString(username), dev.ParamString(email), dev.ParamString(password), dev.ParamInt(invited_by)], )
}

pub type GetUserByEmailOrUsername {
  GetUserByEmailOrUsername(
    email: String,
    username: String
  )
}

pub fn get_user_by_email_or_username(email email: String, username username: String){
  let sql = "SELECT
    user.email,
    user.username
FROM
    user
WHERE
    user.email = ?
    OR user.username = ?"
  #(sql, [dev.ParamString(email), dev.ParamString(username)], get_user_by_email_or_username_decoder())
}

pub fn get_user_by_email_or_username_decoder() -> decode.Decoder(GetUserByEmailOrUsername) {
  use email <- decode.field(0, decode.string)
  use username <- decode.field(1, decode.string)
  decode.success(GetUserByEmailOrUsername(email: , username: ))
}

pub type GetUserByEmail {
  GetUserByEmail(
    id: Int,
    username: String,
    email: String,
    password: String,
    invited_by: Option(Int)
  )
}

pub fn get_user_by_email(email email: String){
  let sql = "SELECT
    user.id,
    user.username,
    user.email,
    user.password,
    user.invited_by
FROM
    user
WHERE
    user.email = ?"
  #(sql, [dev.ParamString(email)], get_user_by_email_decoder())
}

pub fn get_user_by_email_decoder() -> decode.Decoder(GetUserByEmail) {
  use id <- decode.field(0, decode.int)
  use username <- decode.field(1, decode.string)
  use email <- decode.field(2, decode.string)
  use password <- decode.field(3, decode.string)
  use invited_by <- decode.field(4, decode.optional(decode.int))
  decode.success(GetUserByEmail(id: , username: , email: , password: , invited_by: ))
}

pub type GetUserById {
  GetUserById(
    id: Int,
    username: String,
    email: String,
    password: String,
    invited_by: Option(Int)
  )
}

pub fn get_user_by_id(id id: Int){
  let sql = "SELECT
    user.id,
    user.username,
    user.email,
    user.password,
    user.invited_by
FROM
    user
WHERE
    user.id = ?"
  #(sql, [dev.ParamInt(id)], get_user_by_id_decoder())
}

pub fn get_user_by_id_decoder() -> decode.Decoder(GetUserById) {
  use id <- decode.field(0, decode.int)
  use username <- decode.field(1, decode.string)
  use email <- decode.field(2, decode.string)
  use password <- decode.field(3, decode.string)
  use invited_by <- decode.field(4, decode.optional(decode.int))
  decode.success(GetUserById(id: , username: , email: , password: , invited_by: ))
}

pub type GetUserByUsername {
  GetUserByUsername(
    id: Int,
    username: String,
    email: String,
    password: String,
    invited_by: Option(Int)
  )
}

pub fn get_user_by_username(username username: String){
  let sql = "SELECT
    user.id,
    user.username,
    user.email,
    user.password,
    user.invited_by
FROM
    user
WHERE
    user.username = ?"
  #(sql, [dev.ParamString(username)], get_user_by_username_decoder())
}

pub fn get_user_by_username_decoder() -> decode.Decoder(GetUserByUsername) {
  use id <- decode.field(0, decode.int)
  use username <- decode.field(1, decode.string)
  use email <- decode.field(2, decode.string)
  use password <- decode.field(3, decode.string)
  use invited_by <- decode.field(4, decode.optional(decode.int))
  decode.success(GetUserByUsername(id: , username: , email: , password: , invited_by: ))
}

pub fn update_user_password(password password: String, id id: Int){
  let sql = "UPDATE user
SET
    password = ?
WHERE
    user.id = ?"
  #(sql, [dev.ParamString(password), dev.ParamInt(id)], )
}

pub fn create_user_session(user_id user_id: Int, token token: String){
  let sql = "INSERT INTO
    user_session (user_id, token)
VALUES
    (?, ?)"
  #(sql, [dev.ParamInt(user_id), dev.ParamString(token)], )
}

pub type GetUserIdFromSession {
  GetUserIdFromSession(
    id: Int,
    user_id: Int
  )
}

pub fn get_user_id_from_session(token token: String){
  let sql = "SELECT
    user_session.id,
    user_session.user_id
FROM
    user_session
WHERE
    user_session.token = ?"
  #(sql, [dev.ParamString(token)], get_user_id_from_session_decoder())
}

pub fn get_user_id_from_session_decoder() -> decode.Decoder(GetUserIdFromSession) {
  use id <- decode.field(0, decode.int)
  use user_id <- decode.field(1, decode.int)
  decode.success(GetUserIdFromSession(id: , user_id: ))
}

pub fn create_forgot_password(user_id user_id: Int, token token: String){
  let sql = "INSERT INTO
    user_forgot_password (user_id, token)
VALUES
    (?, ?)"
  #(sql, [dev.ParamInt(user_id), dev.ParamString(token)], )
}

pub type GetUserByForgotPassword {
  GetUserByForgotPassword(
    id: Int,
    user_id: Int
  )
}

pub fn get_user_by_forgot_password(token token: String){
  let sql = "SELECT
    user_forgot_password.id,
    user_forgot_password.user_id
FROM
    user_forgot_password
WHERE
    user_forgot_password.token = ?
    AND user_forgot_password.used = FALSE"
  #(sql, [dev.ParamString(token)], get_user_by_forgot_password_decoder())
}

pub fn get_user_by_forgot_password_decoder() -> decode.Decoder(GetUserByForgotPassword) {
  use id <- decode.field(0, decode.int)
  use user_id <- decode.field(1, decode.int)
  decode.success(GetUserByForgotPassword(id: , user_id: ))
}

pub fn update_forgot_password_as_used(token token: String){
  let sql = "UPDATE user_forgot_password
SET
    used = TRUE
WHERE
    token = ?"
  #(sql, [dev.ParamString(token)], )
}

pub fn create_post_comment(body body: String, user_id user_id: Int, post_id post_id: Int, parent_id parent_id: Int){
  let sql = "INSERT INTO
    post_comment (body, user_id, post_id, parent_id)
VALUES
    (?, ?, ?, ?)"
  #(sql, [dev.ParamString(body), dev.ParamInt(user_id), dev.ParamInt(post_id), dev.ParamInt(parent_id)], )
}

pub fn create_post_comment_no_parent(body body: String, user_id user_id: Int, post_id post_id: Int){
  let sql = "INSERT INTO
    post_comment (body, user_id, post_id, parent_id)
VALUES
    (?, ?, ?, NULL)"
  #(sql, [dev.ParamString(body), dev.ParamInt(user_id), dev.ParamInt(post_id)], )
}

pub type GetPostCommentsByPostId {
  GetPostCommentsByPostId(
    id: Int,
    body: String,
    username: Option(String),
    like_count: Int,
    parent_id: Option(Int),
    created_at: Int
  )
}

pub fn get_post_comments_by_post_id(post_id post_id: Int){
  let sql = "SELECT
    post_comment.id,
    post_comment.body,
    user.username,
    COUNT(DISTINCT user_like_post_comment.id) AS like_count,
    post_comment.parent_id,
    UNIX_TIMESTAMP (post_comment.created_at) AS created_at
FROM
    post_comment
    LEFT JOIN user_like_post_comment ON post_comment.id = user_like_post_comment.post_comment_id
    AND user_like_post_comment.status = 'like'
    LEFT JOIN user ON post_comment.user_id = user.id
WHERE
    post_comment.post_id = ?
GROUP BY
    post_comment.id,
    user.username
ORDER BY
    post_comment.created_at DESC"
  #(sql, [dev.ParamInt(post_id)], get_post_comments_by_post_id_decoder())
}

pub fn get_post_comments_by_post_id_decoder() -> decode.Decoder(GetPostCommentsByPostId) {
  use id <- decode.field(0, decode.int)
  use body <- decode.field(1, decode.string)
  use username <- decode.field(2, decode.optional(decode.string))
  use like_count <- decode.field(3, decode.int)
  use parent_id <- decode.field(4, decode.optional(decode.int))
  use created_at <- decode.field(5, decode.int)
  decode.success(GetPostCommentsByPostId(id: , body: , username: , like_count: , parent_id: , created_at: ))
}

pub type GetPostCommentsById {
  GetPostCommentsById(
    id: Int,
    body: String,
    username: Option(String),
    like_count: Int,
    parent_id: Option(Int),
    created_at: Int
  )
}

pub fn get_post_comments_by_id(id id: Int){
  let sql = "SELECT
    post_comment.id,
    post_comment.body,
    user.username,
    COUNT(DISTINCT user_like_post_comment.id) AS like_count,
    post_comment.parent_id,
    UNIX_TIMESTAMP (post_comment.created_at) AS created_at
FROM
    post_comment
    LEFT JOIN user_like_post_comment ON post_comment.id = user_like_post_comment.post_comment_id
    AND user_like_post_comment.status = 'like'
    LEFT JOIN user ON post_comment.user_id = user.id
WHERE
    post_comment.id = ?
GROUP BY
    post_comment.id,
    user.username
ORDER BY
    post_comment.created_at DESC"
  #(sql, [dev.ParamInt(id)], get_post_comments_by_id_decoder())
}

pub fn get_post_comments_by_id_decoder() -> decode.Decoder(GetPostCommentsById) {
  use id <- decode.field(0, decode.int)
  use body <- decode.field(1, decode.string)
  use username <- decode.field(2, decode.optional(decode.string))
  use like_count <- decode.field(3, decode.int)
  use parent_id <- decode.field(4, decode.optional(decode.int))
  use created_at <- decode.field(5, decode.int)
  decode.success(GetPostCommentsById(id: , body: , username: , like_count: , parent_id: , created_at: ))
}

pub type GetPostCommentParentInPost {
  GetPostCommentParentInPost(
    body: String,
    user_id: Int
  )
}

pub fn get_post_comment_parent_in_post(post_id post_id: Int, id id: Int){
  let sql = "SELECT
    post_comment.body,
    post_comment.user_id
FROM
    post_comment
WHERE
    post_comment.post_id = ?
    AND post_comment.id = ?"
  #(sql, [dev.ParamInt(post_id), dev.ParamInt(id)], get_post_comment_parent_in_post_decoder())
}

pub fn get_post_comment_parent_in_post_decoder() -> decode.Decoder(GetPostCommentParentInPost) {
  use body <- decode.field(0, decode.string)
  use user_id <- decode.field(1, decode.int)
  decode.success(GetPostCommentParentInPost(body: , user_id: ))
}

pub type GetCommentsForSitemap {
  GetCommentsForSitemap(
    id: Int,
    created_at: Int
  )
}

pub fn get_comments_for_sitemap(post_id post_id: Int){
  let sql = "SELECT
    post_comment.id,
    UNIX_TIMESTAMP (post_comment.created_at) AS created_at
FROM
    post_comment
WHERE
    post_comment.post_id = ?
ORDER BY
    post_comment.created_at DESC"
  #(sql, [dev.ParamInt(post_id)], get_comments_for_sitemap_decoder())
}

pub fn get_comments_for_sitemap_decoder() -> decode.Decoder(GetCommentsForSitemap) {
  use id <- decode.field(0, decode.int)
  use created_at <- decode.field(1, decode.int)
  decode.success(GetCommentsForSitemap(id: , created_at: ))
}

pub fn create_post_with_body(title title: String, body body: String, user_id user_id: Int, original_creator original_creator: Int){
  let sql = "INSERT INTO
    post (title, body, user_id, original_creator)
VALUES
    (?, ?, ?, ?)"
  #(sql, [dev.ParamString(title), dev.ParamString(body), dev.ParamInt(user_id), dev.ParamInt(original_creator)], )
}

pub fn create_post_with_href(title title: String, href href: String, user_id user_id: Int, original_creator original_creator: Int){
  let sql = "INSERT INTO
    post (title, href, user_id, original_creator)
VALUES
    (?, ?, ?, ?)"
  #(sql, [dev.ParamString(title), dev.ParamString(href), dev.ParamInt(user_id), dev.ParamInt(original_creator)], )
}

pub type GetPostById {
  GetPostById(
    id: Int,
    title: String,
    href: Option(String),
    body: Option(String),
    username: Option(String),
    original_creator: Int,
    like_count: Int,
    comment_count: Int,
    created_at: Int
  )
}

pub fn get_post_by_id(id id: Int){
  let sql = "SELECT
    post.id,
    post.title,
    post.href,
    post.body,
    user.username,
    post.original_creator,
    COUNT(DISTINCT user_like_post.id) AS like_count,
    COUNT(DISTINCT post_comment.id) AS comment_count,
    UNIX_TIMESTAMP (post.created_at) AS created_at
FROM
    post
    LEFT JOIN user_like_post ON post.id = user_like_post.post_id
    AND user_like_post.status = 'like'
    LEFT JOIN post_comment ON post.id = post_comment.post_id
    LEFT JOIN user ON post.user_id = user.id
WHERE
    post.id = ?
GROUP BY
    post.id,
    user.username
ORDER BY
    post.created_at DESC
LIMIT
    25"
  #(sql, [dev.ParamInt(id)], get_post_by_id_decoder())
}

pub fn get_post_by_id_decoder() -> decode.Decoder(GetPostById) {
  use id <- decode.field(0, decode.int)
  use title <- decode.field(1, decode.string)
  use href <- decode.field(2, decode.optional(decode.string))
  use body <- decode.field(3, decode.optional(decode.string))
  use username <- decode.field(4, decode.optional(decode.string))
  use original_creator <- decode.field(5, decode.int)
  use like_count <- decode.field(6, decode.int)
  use comment_count <- decode.field(7, decode.int)
  use created_at <- decode.field(8, decode.int)
  decode.success(GetPostById(id: , title: , href: , body: , username: , original_creator: , like_count: , comment_count: , created_at: ))
}

pub type GetPostByHref {
  GetPostByHref(
    title: String,
    href: Option(String)
  )
}

pub fn get_post_by_href(href href: String){
  let sql = "SELECT
    post.title,
    post.href
FROM
    post
WHERE
    post.href = ?"
  #(sql, [dev.ParamString(href)], get_post_by_href_decoder())
}

pub fn get_post_by_href_decoder() -> decode.Decoder(GetPostByHref) {
  use title <- decode.field(0, decode.string)
  use href <- decode.field(1, decode.optional(decode.string))
  decode.success(GetPostByHref(title: , href: ))
}

pub type GetPosts {
  GetPosts(
    id: Int,
    title: String,
    href: Option(String),
    body: Option(String),
    username: Option(String),
    original_creator: Int,
    like_count: Int,
    comment_count: Int,
    created_at: Int
  )
}

pub fn get_posts(){
  let sql = "SELECT
    post.id,
    post.title,
    post.href,
    post.body,
    user.username,
    post.original_creator,
    COUNT(DISTINCT user_like_post.id) AS like_count,
    COUNT(DISTINCT post_comment.id) AS comment_count,
    UNIX_TIMESTAMP (post.created_at) AS created_at
FROM
    post
    LEFT JOIN user_like_post ON post.id = user_like_post.post_id
    AND user_like_post.status = 'like'
    LEFT JOIN post_comment ON post.id = post_comment.post_id
    LEFT JOIN user ON post.user_id = user.id
GROUP BY
    post.id,
    user.username
ORDER BY
    post.created_at DESC"
  #(sql, [], get_posts_decoder())
}

pub fn get_posts_decoder() -> decode.Decoder(GetPosts) {
  use id <- decode.field(0, decode.int)
  use title <- decode.field(1, decode.string)
  use href <- decode.field(2, decode.optional(decode.string))
  use body <- decode.field(3, decode.optional(decode.string))
  use username <- decode.field(4, decode.optional(decode.string))
  use original_creator <- decode.field(5, decode.int)
  use like_count <- decode.field(6, decode.int)
  use comment_count <- decode.field(7, decode.int)
  use created_at <- decode.field(8, decode.int)
  decode.success(GetPosts(id: , title: , href: , body: , username: , original_creator: , like_count: , comment_count: , created_at: ))
}

pub type GetPostsUnlimited {
  GetPostsUnlimited(
    id: Int,
    title: String,
    href: Option(String),
    body: Option(String),
    username: Option(String),
    original_creator: Int,
    like_count: Int,
    comment_count: Int,
    created_at: Int
  )
}

pub fn get_posts_unlimited(){
  let sql = "SELECT
    post.id,
    post.title,
    post.href,
    post.body,
    user.username,
    post.original_creator,
    COUNT(DISTINCT user_like_post.id) AS like_count,
    COUNT(DISTINCT post_comment.id) AS comment_count,
    UNIX_TIMESTAMP (post.created_at) AS created_at
FROM
    post
    LEFT JOIN user_like_post ON post.id = user_like_post.post_id
    AND user_like_post.status = 'like'
    LEFT JOIN post_comment ON post.id = post_comment.post_id
    LEFT JOIN user ON post.user_id = user.id
GROUP BY
    post.id,
    user.username
ORDER BY
    post.created_at DESC
LIMIT
    25"
  #(sql, [], get_posts_unlimited_decoder())
}

pub fn get_posts_unlimited_decoder() -> decode.Decoder(GetPostsUnlimited) {
  use id <- decode.field(0, decode.int)
  use title <- decode.field(1, decode.string)
  use href <- decode.field(2, decode.optional(decode.string))
  use body <- decode.field(3, decode.optional(decode.string))
  use username <- decode.field(4, decode.optional(decode.string))
  use original_creator <- decode.field(5, decode.int)
  use like_count <- decode.field(6, decode.int)
  use comment_count <- decode.field(7, decode.int)
  use created_at <- decode.field(8, decode.int)
  decode.success(GetPostsUnlimited(id: , title: , href: , body: , username: , original_creator: , like_count: , comment_count: , created_at: ))
}

pub type GetLatestPostByUserId {
  GetLatestPostByUserId(
    id: Int,
    title: String,
    href: Option(String),
    body: Option(String),
    username: Option(String),
    original_creator: Int,
    like_count: Int,
    comment_count: Int,
    created_at: Int
  )
}

pub fn get_latest_post_by_user_id(user_id user_id: Int){
  let sql = "SELECT
    post.id,
    post.title,
    post.href,
    post.body,
    user.username,
    post.original_creator,
    COUNT(DISTINCT user_like_post.id) AS like_count,
    COUNT(DISTINCT post_comment.id) AS comment_count,
    UNIX_TIMESTAMP (post.created_at) AS created_at
FROM
    post
    LEFT JOIN user_like_post ON post.id = user_like_post.post_id
    AND user_like_post.status = 'like'
    LEFT JOIN post_comment ON post.id = post_comment.post_id
    LEFT JOIN user ON post.user_id = user.id
WHERE
    post.user_id = ?
GROUP BY
    post.id,
    user.username
ORDER BY
    post.created_at DESC
LIMIT
    1"
  #(sql, [dev.ParamInt(user_id)], get_latest_post_by_user_id_decoder())
}

pub fn get_latest_post_by_user_id_decoder() -> decode.Decoder(GetLatestPostByUserId) {
  use id <- decode.field(0, decode.int)
  use title <- decode.field(1, decode.string)
  use href <- decode.field(2, decode.optional(decode.string))
  use body <- decode.field(3, decode.optional(decode.string))
  use username <- decode.field(4, decode.optional(decode.string))
  use original_creator <- decode.field(5, decode.int)
  use like_count <- decode.field(6, decode.int)
  use comment_count <- decode.field(7, decode.int)
  use created_at <- decode.field(8, decode.int)
  decode.success(GetLatestPostByUserId(id: , title: , href: , body: , username: , original_creator: , like_count: , comment_count: , created_at: ))
}

pub fn create_post_tag(post_id post_id: Int, tag_id tag_id: Int){
  let sql = "INSERT INTO
    post_tag (post_id, tag_id)
VALUES
    (?, ?)"
  #(sql, [dev.ParamInt(post_id), dev.ParamInt(tag_id)], )
}

pub type GetPostTags {
  GetPostTags(
    post_id: Int,
    tag_id: Int
  )
}

pub fn get_post_tags(post_id post_id: Int, tag_id tag_id: Int){
  let sql = "SELECT
    post_tag.post_id,
    post_tag.tag_id
FROM
    post_tag
WHERE
    post_tag.post_id = ?
    AND post_tag.tag_id = ?"
  #(sql, [dev.ParamInt(post_id), dev.ParamInt(tag_id)], get_post_tags_decoder())
}

pub fn get_post_tags_decoder() -> decode.Decoder(GetPostTags) {
  use post_id <- decode.field(0, decode.int)
  use tag_id <- decode.field(1, decode.int)
  decode.success(GetPostTags(post_id: , tag_id: ))
}

pub type GetTagsByPostId {
  GetTagsByPostId(
    id: Option(Int),
    name: Option(String)
  )
}

pub fn get_tags_by_post_id(post_id post_id: Int){
  let sql = "SELECT
    tag.id,
    tag.name
FROM
    post_tag
    LEFT JOIN tag ON tag.id = post_tag.tag_id
WHERE
    post_tag.post_id = ?"
  #(sql, [dev.ParamInt(post_id)], get_tags_by_post_id_decoder())
}

pub fn get_tags_by_post_id_decoder() -> decode.Decoder(GetTagsByPostId) {
  use id <- decode.field(0, decode.optional(decode.int))
  use name <- decode.field(1, decode.optional(decode.string))
  decode.success(GetTagsByPostId(id: , name: ))
}

pub type GetTagsById {
  GetTagsById(
    id: Int,
    name: String,
    category: decode.Dynamic,
    permission: decode.Dynamic
  )
}

pub fn get_tags_by_id(id id: Int){
  let sql = "SELECT
    tag.id,
    tag.name,
    tag.category,
    tag.permission
FROM
    tag
WHERE
    tag.id = ?"
  #(sql, [dev.ParamInt(id)], get_tags_by_id_decoder())
}

pub fn get_tags_by_id_decoder() -> decode.Decoder(GetTagsById) {
  use id <- decode.field(0, decode.int)
  use name <- decode.field(1, decode.string)
  use category <- decode.field(2, decode.dynamic)
  use permission <- decode.field(3, decode.dynamic)
  decode.success(GetTagsById(id: , name: , category: , permission: ))
}

pub type GetTags {
  GetTags(
    id: Int,
    name: String,
    category: decode.Dynamic,
    permission: decode.Dynamic
  )
}

pub fn get_tags(){
  let sql = "SELECT
    tag.id,
    tag.name,
    tag.category,
    tag.permission
FROM
    tag"
  #(sql, [], get_tags_decoder())
}

pub fn get_tags_decoder() -> decode.Decoder(GetTags) {
  use id <- decode.field(0, decode.int)
  use name <- decode.field(1, decode.string)
  use category <- decode.field(2, decode.dynamic)
  use permission <- decode.field(3, decode.dynamic)
  decode.success(GetTags(id: , name: , category: , permission: ))
}

pub fn create_user_like_post(user_id user_id: Int, post_id post_id: Int, status status: decode.Dynamic){
  let sql = "INSERT INTO
    user_like_post (user_id, post_id, status)
VALUES
    (?, ?, ?)"
  #(sql, [dev.ParamInt(user_id), dev.ParamInt(post_id), dev.ParamDynamic(status)], )
}

pub fn create_user_like_post_comment(user_id user_id: Int, post_id post_id: Int, status status: decode.Dynamic){
  let sql = "INSERT INTO
    user_like_post (user_id, post_id, status)
VALUES
    (?, ?, ?)"
  #(sql, [dev.ParamInt(user_id), dev.ParamInt(post_id), dev.ParamDynamic(status)], )
}

pub type GetUserPostLikes {
  GetUserPostLikes(
    id: Int,
    user_id: Int,
    post_id: Int,
    status: decode.Dynamic
  )
}

pub fn get_user_post_likes(user_id user_id: Int, post_id post_id: Int){
  let sql = "SELECT
    user_like_post.id,
    user_like_post.user_id,
    user_like_post.post_id,
    user_like_post.status
FROM
    user_like_post
WHERE
    user_like_post.user_id = ?
    AND user_like_post.post_id = ?"
  #(sql, [dev.ParamInt(user_id), dev.ParamInt(post_id)], get_user_post_likes_decoder())
}

pub fn get_user_post_likes_decoder() -> decode.Decoder(GetUserPostLikes) {
  use id <- decode.field(0, decode.int)
  use user_id <- decode.field(1, decode.int)
  use post_id <- decode.field(2, decode.int)
  use status <- decode.field(3, decode.dynamic)
  decode.success(GetUserPostLikes(id: , user_id: , post_id: , status: ))
}

pub type GetUserPostCommentLikes {
  GetUserPostCommentLikes(
    id: Int,
    user_id: Int,
    post_comment_id: Int,
    status: decode.Dynamic
  )
}

pub fn get_user_post_comment_likes(user_id user_id: Int, post_comment_id post_comment_id: Int){
  let sql = "SELECT
    user_like_post_comment.id,
    user_like_post_comment.user_id,
    user_like_post_comment.post_comment_id,
    user_like_post_comment.status
FROM
    user_like_post_comment
WHERE
    user_like_post_comment.user_id = ?
    AND user_like_post_comment.post_comment_id = ?"
  #(sql, [dev.ParamInt(user_id), dev.ParamInt(post_comment_id)], get_user_post_comment_likes_decoder())
}

pub fn get_user_post_comment_likes_decoder() -> decode.Decoder(GetUserPostCommentLikes) {
  use id <- decode.field(0, decode.int)
  use user_id <- decode.field(1, decode.int)
  use post_comment_id <- decode.field(2, decode.int)
  use status <- decode.field(3, decode.dynamic)
  decode.success(GetUserPostCommentLikes(id: , user_id: , post_comment_id: , status: ))
}

pub fn update_user_like_post_status(status status: decode.Dynamic, id id: Int){
  let sql = "UPDATE user_like_post
SET
    status = ?
WHERE
    id = ?"
  #(sql, [dev.ParamDynamic(status), dev.ParamInt(id)], )
}

pub fn update_user_like_post_comment_status(status status: decode.Dynamic, id id: Int){
  let sql = "UPDATE user_like_post_comment
SET
    status = ?
WHERE
    id = ?"
  #(sql, [dev.ParamDynamic(status), dev.ParamInt(id)], )
}